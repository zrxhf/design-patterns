### 设计原则

+ 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

+ 针对接口编程，而不是针对实现编程。

    > “针对接口编程”真正意思是“针对超类型(supertype)编程”。

+ 多用组合，少用继承。

    > 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果
    能利用组合的做法拓展对象的行为，就可以在运行时动态地进行拓展。

+ 为了交互对象之间的松耦合设计而努力。

    > 松耦合的设计之所以能让我们建立弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降到了最低。

+ 开闭原则：类应该对拓展开放，对修改关闭。

    > 虽然似乎有些矛盾，但是的确有一些技术可以允许在不直接修改代码的情况下对其进行拓展。
    在选择需要被拓展的代码部分要小心。每个地方都采用开闭原则是一种浪费，也没必要，还会导致代码变得复杂且难以理解。

+ 依赖倒置原则：要依赖抽象，不要依赖具体类

    > 首先，这个原则听起来很像是"针对接口编程，不针对实现编程"，不是吗？的确很相似，然而这里更强调"抽象"。
    这个原则说明了：不能让高层组件依赖低层组件，而且，不管高层或低层组件，"两者"都应该依赖抽象。(所谓"高层"
    组件，是由其他低层组件定义其行为的类。)

+ 最少知识原则/迪米特法则：只和你的密友谈话。

    > 当你正在设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。

+ 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。

    > 好莱坞原则可以给我们一种防止"依赖腐败"的方法。在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，
    但是高层组件会决定什么时候和怎样使用这些低层组件。

+ 单一职责原则：一个类应该只有一个引起变化的原因。


### 设计模式

+ 策略模式

    > 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

+ 观察者模式

    > 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

+ 装饰者模式

    > 动态地将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。

+ 工厂方法模式

    > 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

    > 利用了继承。所以这意味着，利用工厂方法创建对象，需要拓展一个类，并覆盖它的工厂方法。工厂方法
    用来创建对象。其实整个工厂方法模式，只不过就是通过子类来创建对象。

+ 抽象工厂模式

    > 提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

    > 利用了组合。提供了一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。
    要想使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中。

+ 单件模式

    > 确保一个类只有一个实例，并提供一个全局访问点。

    > 实现方法：同步getInstance()方法、急切实例化、双重检查加锁。

+ 命令模式

    > 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。

+ 适配器模式

    > 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

+ 外观模式

    > 提供了一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。

+ 模板方法模式

    > 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。
    模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

+ 迭代器模式

    > 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

+ 组合模式

    > 允许你将对象组成树形结构表现"整体/部分"的层次结构。组合能让客户以一致的方式处理个别对象和对象组合。

+ 状态模式

    > 允许对象再内部状态改变时改变它的行为，对象看起来好像修改了它的类。

+ 代理模式

    > 为另一个对象提供一个替身或占位符以控制对这个对象的访问。

    > 使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

+ 复合模式

    > 复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。


### 章节要点

1. #### 设计模式入门

    + 知道OO基础，并不足让你设计出良好设计的系统。
    + 良好的OO设计必须具备可复用、可扩充、可维护三个特性。
    + 模式可以让我们建造出具有良好OO设计质量的系统。
    + 模式被认为是历经验证的OO设计经验。
    + 模式不是代码，而是针对设计问题的通用代码解决方案。你可以把它们应用到特定的应用中。
    + 模式不是被发明，而是被发现。
    + 大多数的模式和原则，都着眼于软件变化的主题。
    + 大多数的模式都允许系统局部改变独立于其他部分。
    + 我们通常把系统中会变化的部分抽出来封装。
    + 模式让开发人员之间有共享的语言，能够最大化沟通的价值。

2. #### 观察者模式

    + 观察者模式定义了对象之间一对多的关系。
    + 主题（也就是可观察者）用一个共同的接口来更新观察者。
    + 观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
    + 使用此模式，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更"正确")。
    + 有多个观察者时，不可以依赖特定的通知次序。
    + Java有多个观察者模式的实现，包括了通用的java.util.Observable。
    + 要注意java.util.Observable实现上所带来的一些问题。
    + 如果有必要的话，可以实现自己的Observable，这并不难，不要害怕。
    + Swing大量使用观察者模式，许多GUI框架也是如此。
    + 此模式也被应用在许多地方，例如：JavaBeans、RMI。

3. #### 装饰者模式

    + 继承属于拓展形式之一，但不见得是达到弹性设计的最佳方法。
    + 在我们的设计中，应该允许行为可以被拓展，而无须修改现有的代码。
    + 组合和委托可用于在运行时动态地加上新的行为。
    + 除了继承，装饰者模式也可以让我们拓展行为。
    + 装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
    + 装饰者类反映出被装饰者的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
    + 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
    + 你可以使用无数个装饰者来包装一个组件。
    + 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
    + 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

4. #### 工厂模式

    + 所有的工厂都是用来封装对象的创建。
    + 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。
    + 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
    + 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。
    + 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。
    + 工厂方法允许类将实例化延迟到子类进行。
    + 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。
    + 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。
    + 工厂是很威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。

5. #### 单件模式

    + 单件模式确保程序中一个类最多只有一个实例。
    + 单件模式也提供访问这个实例的全局点。
    + 在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。
    + 确定在性能和资源上的限制，然后小心的选择适当的方案来实现单件，以解决多线程的问题(我们必须确认所有程序都是多线程的)。
    + 如果不是采用第五版的Java 2，双重检查加锁实现会失效。
    + 小心，如果使用多个类加载器，可能导致单件失效而产生多个实例。
    + 如果使用JVM 1.2 或之前的版本，必须建立单件注册表，以免垃圾收集器将单件回收。

6. #### 命令模式

    + 命令模式将发出请求的对象和执行请求的对象解耦。
    + 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个/一组动作。
    + 调用者可以通过命令对象的execute()发出请求，这会使得接收者的动作被调用。
    + 调用者可以接受命令当做参数，甚至在运行是动态地进行。
    + 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态。
    + 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。
    + 实际操作时，很常见使用"聪明"对象直接实现了请求，而不是将工作委托给接收者。
    + 命令也可以用来实现日志和事务系统。

7. #### 适配器与外观模式

    + 当需要使用一个现有类而其接口不符合你的需要时，就使用适配器。
    + 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。
    + 适配器改变接口以符合客户的期望。
    + 外观将客户从一个复杂的子系统中解耦。
    + 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小和复杂度而定。
    + 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。
    + 适配器模式有两种形式：对象适配器模式和类适配器。类适配器需要用到多重继承。
    + 你可以为一个子系统实现一个以上的外观。
    + 适配器将一个对象包装起来以改变其接口。
    + 装饰者对一个对象包装起来以增加新的行为和责任。
    + 外观将一群对象"包装"起来以简化其接口。

8. #### 模板方法模式

    + "模板方法"定义了算法的步骤，把这些不走的实现延迟到子类。
    + 模板方法为我们提供了一种代码复用的重要技巧。
    + 模板方法的抽象类可以定义具体方法、抽象方法和钩子。
    + 抽象方法有子类实现。
    + 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。
    + 为了防止子类改变模板方法中的算法，可以将模板方法声明为final。
    + 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块。
    + 你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的。
    + 策略模式和模板方法都封装算法，一个用组合，一个用继承。
    + 工厂方法是模板方法的一种特殊版本。

9. #### 迭代器与组合模式

    + 迭代器允许访问聚合的元素，而不需要暴露它的内部结构。
    + 迭代器将遍历聚合的工作封装进一个对象中。
    + 当使用迭代器的时候，我们依赖聚合提供遍历。
    + 迭代器提供了一个通用的接口，让我们遍历聚合的项时，当我们编码使用聚合的项时，就可以使用多态机制。
    + 我们应该努力让一个类只分配一个责任。
    + 组合模式提供一个结构，可同时包容个别对象和组合对象。
    + 组合模式允许客户对个别对象以及组合对象一视同仁。
    + 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。
    + 在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性和安全性。

10. #### 状态模式

    + 状态模式允许一个对象基于内部状态而拥有不同的行为。
    + 和程序状态机（PSM）不同，状态模式用类代表状态。
    + Context会将行为委托给当前状态对象。
    + 通过将每个状态封装进一个类，我们把以后需要作的任何改变局部化了。
    + 状态模式和策略模式有相同的类图，但是它们的意图不同。
    + 策略模式通常会用行为或算法来配置Context类。
    + 状态模式允许Context随着状态的改变而改变行为。
    + 状态转换可以由State类或Context类控制。
    + 使用状态模式通常会导致设计类的数目大量增加。
    + 状态类可以被多个Context实例共享。

11. #### 代理模式

    + 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。
    + 远程代理管理客户和远程对象之间的交互。
    + 虚拟代理控制访问实例化开销大的对象。
    + 保护代理基于调用者控制对象方法的访问。
    + 代理模式有很多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。
    + 代理在结构上类似装饰者，但是目的不同。
    + 装饰者为对象加上行为，而代理则是控制访问。
    + Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
    + 就和其他的包装者一样，代理会造成设计中类的数目增加。

12. #### 复合模式

    + MVC是复合模式，结合了观察者模式、策略模式、组合模式。
    + 模型使用观察者模式，以便观察者更新，同时保持两者之间解耦。
    + 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。
    + 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。
    + 这些模式携手合作，把MVC模型的三层解耦，这样可以保持设计干净又有弹性。
    + 适配器模式用来将新的模型适配成已有的视图和控制器。
    + Model 2是MVC在Web上的应用。
    + 在Model 2中，控制器实现成Servlet，而JSP/HTML实现视图。

### 类图

1. #### 策略模式

    ![UML](uml/strategy.png)
